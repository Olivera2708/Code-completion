[
    {
        "correct": "        start = prices[0]\n",
        "generated": "        for i in range(1, len(prices)):\n            if prices[i] > max:\n                max = prices[i]\n"
    },
    {
        "correct": "\t\t\t\treturn False\n",
        "generated": "\t\t\t\treturn False\n"
    },
    {
        "correct": "\t\t\t\t\treturn prefix\n",
        "generated": "\t\t\t\tprefix += p\n\t\t\ti += 1\n\t\t\tprefix += p\n\t\t\tif i == len(strs[0]):\n\t\t\t\tretur"
    },
    {
        "correct": "        }\n",
        "generated": "        }\n        result = []\n        for i in digits:\n            if i in keyboard:\n                result.append(keyboard[i])\n            else"
    },
    {
        "correct": "            current = max(prev1, prev2 + num)\n",
        "generated": "            if num > prev1:\n                prev1 = num\n            if num > prev2:\n    "
    },
    {
        "correct": "        while len(to_visit) > 0 or len(next_visit) > 0:\n",
        "generated": "        while to_visit:\n            node = to_visit.popleft()\n            if node.left is not None:\n                next_visit"
    },
    {
        "correct": "\t\tsett = set()\n",
        "generated": "\t"
    },
    {
        "correct": "\t\t\tif (s[i] in map1 and map1[s[i]] != t[i]) or (s[i] not in map1 and t[i] in map2):\n",
        "generated": "\t\t\tif s[i] in map1:\n\t\t\t\tmap1[s[i]] = map1[s[i]] +"
    },
    {
        "correct": "        head.next = None\n",
        "generated": "        fast = head\n        previous = head\n        while fast is not None:\n    "
    },
    {
        "correct": "        current = self.root\n",
        "generated": "        current = self.root\n"
    },
    {
        "correct": "\t\t\tif (pattern[i] in map1 and map1[pattern[i]] != words[i]) or (pattern[i] not in map1 and words[i] in map2):\n",
        "generated": "\t\t\tif words[i] in map1:\n\t\t\t\tmap1[words[i]] = map1[words[i]] +"
    },
    {
        "correct": "            if n/k < 1:\n",
        "generated": "            for i in range(k, n+1):\n                if i == 0:\n                    res.append(current)\n                else:\n                  "
    },
    {
        "correct": "\t\t\t\tif abs(dict[nums[i]] - i) <= k:\n",
        "generated": "\t\t\t\treturn False\n\t\tfor i in range(len(nums)):\n\t\t\tif dict[nums[i]]!= i:\n"
    },
    {
        "correct": "\t\t\t\tif start != nums[i - 1]:\n",
        "generated": "\t\t\t\tres.append(f'{start}->{nums[i - 1]}')\n\t\t\telse:\n\t\t\t\tres.append(f'"
    },
    {
        "correct": "            left = helper(node.left)\n",
        "generated": "            left = helper(node.left)\n"
    },
    {
        "correct": "\t\t\tif nums[i - 1] != nums[i]:\n",
        "generated": "\t\t\t\tif nums[i] == nums[current]:\n\t\t\t\t\tnums[current] = nums[i]\n\t\t\t\t\tcurrent += 1\n\t\t"
    },
    {
        "correct": "\t\tremoved = 0\n",
        "generated": "\t\t\tremoved = 0\n\t\tfor i in range(n):\n\t\t\tif nums[i] == val:\n\t\t\t\tcounter = "
    },
    {
        "correct": "\t\t\t\tj -= i\n",
        "generated": "\t\t\t\tj += 1\n\t\treturn -1\n\n# Time:  O(n)\n# Space: O(1)"
    },
    {
        "correct": "        for i in range(len(nums)):\n",
        "generated": "        for i in range(len(nums)):\n"
    },
    {
        "correct": "            odd.next = odd.next.next\n",
        "generated": "            if even.val == odd.val:\n    "
    },
    {
        "correct": "        if len(nums) < 3:\n",
        "generated": "        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if not nums:\n"
    },
    {
        "correct": "            counter = 0\n",
        "generated": "            counter = 0\n"
    },
    {
        "correct": "        for char in s:\n",
        "generated": "        for char in s:\n"
    },
    {
        "correct": "\t\tdict = {}\n",
        "generated": "\t"
    },
    {
        "correct": "            return True\n",
        "generated": "            return True\n        while index_t < len(t):\n            if s[index_s] == t[index_t]:\n                inde"
    },
    {
        "correct": "        for c in s:\n",
        "generated": "        for c in s:\n            if c == \"(\":\n                stack.append((val, num))\n                val = \"\"\n                num = "
    },
    {
        "correct": "                        cluster += 1\n",
        "generated": "                    visited.add(equation[0])\n"
    },
    {
        "correct": "        intervals.sort(key=lambda x: x[1])\n",
        "generated": "        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n"
    },
    {
        "correct": "        res += str(counter) if counter > 1 else \"\"\n",
        "generated": "        return res\n\n\nclass Solution:\n    def compress(self, chars):\n        res = \"\"\n        for i in range(len(chars))"
    },
    {
        "correct": "    def deleteNode(self, root, key):\n",
        "generated": "    def deleteNode(self, root, key):\n        if not root:\n            return None\n        if root.val < key:\n            root"
    },
    {
        "correct": "        current = points[0][1]\n",
        "generated": "        current = points[0][1]\n"
    },
    {
        "correct": "        for num in nums:\n",
        "generated": "        for num in nums:\n"
    },
    {
        "correct": "\t\t\t\treturn counter\n",
        "generated": "\t\t\t\tcounter += 1\n"
    },
    {
        "correct": "\t\twhile x > 0:\n",
        "generated": "\t\t\twhile x > 0:\n\t\t\tnum *= x\n\t\t\tx -= num\n\t\t\tcounter += 1\n\t\treturn counter if "
    },
    {
        "correct": "        for i in range(m + 1):\n",
        "generated": "        for i in range(n + 1):\n"
    },
    {
        "correct": "\t\ti = 2\n",
        "generated": "\t"
    },
    {
        "correct": "            if nums1[i] > nums2[j]:\n",
        "generated": "            if nums1[i] <= nums2[j]:\n                nums1[i], nums2[j] = nums2[j]"
    }
]